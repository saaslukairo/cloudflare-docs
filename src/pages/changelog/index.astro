---
import StarlightPage, {
	type StarlightPageProps,
} from "@astrojs/starlight/components/StarlightPage.astro";

import Header from "~/components/changelog/Header.astro";
import ProductPills from "~/components/changelog/ProductPills.astro";

import { Steps } from "~/components";
import { format } from "date-fns";
import { getChangelogs } from "~/util/changelog";
import { productsByGroup } from "~/util/products";

import { render } from "astro:content";

let notes = await getChangelogs({
	filter: (entry) => !entry.data.hidden,
});

const seen = new Map<string, number>();

notes = notes.flatMap((note) => {
	const products = note.data.products.map((product) => product.id);

	// PCX-19256 - We only want to count dedicated entries against the product length, otherwise specific entries can get obscured
	if (products.length === 1) {
		for (const product of products) {
			const previous = seen.get(product) || 0;

			seen.set(product, previous + 1);

			if (previous >= 5) {
				return [];
			}
		}
	}

	return note;
});

const props = {
	frontmatter: {
		title: "Changelogs",
		tableOfContents: false,
		template: "splash",
		chatbot_deprioritize: true,
	},
	hideTitle: true,
	hideBreadcrumbs: true,
} as StarlightPageProps;
---

<StarlightPage {...props}>
	<Header notes={notes} />
	{
		notes.map(async (entry, idx) => {
			const date = format(entry.data.date, "MMM dd, yyyy");

			const productIds = entry.data.products.map((product) => product.id);

			const productGroups = productsByGroup
				.filter((group) =>
					group[1]?.find((product) => productIds.includes(product.id)),
				)
				.map((group) => group[0])
				.sort();

			const { Content } = await render(entry);

			return (
				<div
					class:list={["mt-0! sm:flex", { "hidden!": idx >= 50 }]}
					data-products={JSON.stringify(
						productIds.concat(
							productGroups.map((group) =>
								group.replaceAll(" ", "-").toLowerCase(),
							),
						),
					)}
				>
					<time
						datetime={entry.data.date.toISOString()}
						class="text-xs leading-6 font-bold whitespace-nowrap sm:pr-4 sm:text-right"
					>
						{date}
					</time>
					<Steps>
						<ol class="mt-0! overflow-x-auto">
							<li class="pb-16!">
								<div>
									<h3 class="leading-none">
										<a
											href={`/changelog/${entry.id}/`}
											class="mb-4 text-black! no-underline hover:underline"
										>
											{entry.data.title}
										</a>
									</h3>
									<ProductPills products={entry.data.products} />
								</div>
								<Content />
							</li>
						</ol>
					</Steps>
				</div>
			);
		})
	}
	<div class="flex items-center justify-center">
		<a
			id="changelog-search-button"
			href="/search/?contentType=Changelog+entry"
			class="bg-cl1-brand-orange text-cl1-black mr-2 flex h-12 items-center justify-center rounded-sm px-6 font-medium no-underline"
		>
			Search for historical entries
		</a>
	</div>
</StarlightPage>

<script>
	const filter = document.querySelector<HTMLSelectElement>(
		"#changelogs-next-filter",
	);

	const url = new URL(window.location.href);

	if (filter && url.searchParams.has("product")) {
		filter.value = url.searchParams.get("product")!;
		updateFilter();
	}

	filter?.addEventListener("change", updateFilter);

	function filterByProduct(e: HTMLElement, value?: string): boolean {
		if (!value || value === "all") {
			return true;
		}

		if (!e.dataset.products) {
			return false;
		}

		const products: string[] = JSON.parse(e.dataset.products);
		return products.includes(value);
	}

	function updateFilter() {
		const entries = [
			...document.querySelectorAll<HTMLElement>("[data-products]"),
		];

		if (!entries) return;

		const value = filter!.value;

		const filtered = entries
			.filter((e) => filterByProduct(e, value))
			.slice(0, 10);

		for (const entry of entries) {
			const show = filtered.includes(entry);

			if (show) {
				entry.classList.remove("hidden!");
			} else {
				entry.classList.add("hidden!");
			}
		}

		const url = new URL(window.location.href);

		if (value === "all") {
			url.searchParams.delete("product");
		} else {
			url.searchParams.set("product", value);
		}

		history.replaceState(null, "", url.href);
	}
</script>

<style>
	:root {
		.sl-container {
			--sl-content-width: 50rem !important;
			margin-inline: auto !important;
		}

		.feedback-prompt-content {
			display: none !important;
		}

		#footer-links {
			justify-content: center;
		}
	}

	.sl-steps {
		--bullet-size: 24px !important;

		& > li {
			padding-inline-start: calc(var(--bullet-size) + 2.5rem) !important;

			&::before {
				content: "â€¢" !important;
				font-size: calc(var(--bullet-size) * 2) !important;
				line-height: calc(var(--bullet-size) / 1.5) !important;
				color: var(--orange-accent-200) !important;
			}
		}
	}
</style>
